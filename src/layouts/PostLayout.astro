---
import IconArrow from "../components/IconArrow.astro";
import BaseLayout from "./BaseLayout.astro";
import SidePanel from "../components/SidePanel.astro";

import { toTitleCase } from '../scripts/helpers.js';
import { detectType } from '../scripts/helpers.js';

import "../styles/post.css";

const { frontmatter } = Astro.props;

// Determine active project and post
const pagePath = frontmatter.url.split('/');
const activeProject = frontmatter.project;
const activePost = frontmatter.url;

// Get active post content
const postContent = await Astro.props.compiledContent();

// Get project posts
const posts = await Astro.glob('../pages/*/*/*.md');
const projectPosts = posts.filter(post => {
    return post.url.includes(`${activeProject.toLowerCase()}`) && !post.url.includes(`${activePost}`);
})

// Collect all search terms in an array
let searchArr = [];
let searchArrTerms = [];
for (const obj of projectPosts) {
    if (obj.frontmatter.searchTerms) {
        for (const term of obj.frontmatter.searchTerms) {
            searchArr.push({
                term: term,
                url: obj.url
            })
        }
    }
}

// Sort terms from longest to shortest
searchArr.sort((a, b) => b.term.length - a.term.length);
searchArr.map((obj) => searchArrTerms.push(obj.term));

/**
 * Search string for matching search terms
 * @param  {String} string a string to be searched
 * @param  {Array} terms an array of object search terms
 * @param  {Object} relevance (optional) an object of relevance score
 * @return {Object} an object including the edited string and updated relevance score object
 */
let detectMatches = function(string, terms, relevance){
    let editedString = string;
    let editedRelevance;
    if (relevance){
        editedRelevance = relevance;
    } else {
        editedRelevance = {}
    }
    
    for (const obj of terms){
        let term = obj.term;
        // Replace quote marks with regex that captures all types
        term = term.replaceAll("'", "['’]");
        term = term.replaceAll('"', '[“”"]');
        let pattern = `(?<!<a[^>]*)(?<!<[^>]*)(${term})(?![^<]*<\/a>)`;
        let flags = 'gi'; // g for global and i for case-insensitive
        let regex = new RegExp(pattern, flags);
        // Detect matches and add to relevance score
        let matches = editedString.match(regex);
        if (matches && matches.length > 0){
            if (editedRelevance[obj.url]){
                editedRelevance[obj.url] += matches.length;
            } else {
                editedRelevance[obj.url] = matches.length;
            }
        }
        // Wrap matches in links
        editedString = editedString.replaceAll(regex, `<a href="${obj.url}">$&</a>`);
    }

    return {
        string: editedString,
        relevance: editedRelevance 
    }
}

let editedPostContent = detectMatches(postContent, searchArr, null);



/**
 * Construct an html string from a data object
 * @param  {Object} obj a data object
 * @param  {String} startStr an html string to place at the start
 * @param  {String} endStr an html string to place at the end
 * @return {String} an html string
 */
 let constructHTMLFromObject = function(obj, startStr, endStr){
    let htmlStr = '';
    if (startStr){
        htmlStr += startStr;
    }
    htmlStr += Object.keys(obj).map((key) => {
        let valueStr;
        let value = obj[key];
        let valueType = detectType(value);

        if (valueType === 'string'){
            valueStr = `<p>${value}</p>`

        } else if (valueType === 'array'){
            let arrHtmlStr;
            arrHtmlStr = value.map((arrValue) => {
                let arrValueType = detectType(arrValue);

                if (arrValueType === 'string'){
                    return `<li>${arrValue}</li>`;

                } else if (arrValueType === 'object'){
                    let objHtmlStr = Object.values(arrValue).map((objValue) => {
                        return objValue;
                    }).join(': '); 
                    return `<li>${objHtmlStr}</li>`;
                }
            }).join('');
            valueStr = `<ul>${arrHtmlStr}</ul>`;
        }
        return `<div><h3>${toTitleCase(key)}</h3>${valueStr}</div>`;
    }).join('');
    if (endStr){
        htmlStr += endStr;
    }
    return htmlStr;
 }

// Generate HTML for the details
let postDetails = '';
if (frontmatter.details){
    postDetails = constructHTMLFromObject(frontmatter.details, '<div><h2>Details</h2><div>', '</div></div>' );
}

let postConnections = '';
if (frontmatter.connections){
    postConnections = constructHTMLFromObject(frontmatter.connections, '<div><h2>Connections</h2><div>', '</div></div>' );
}

if (postConnections !== ''){
    postDetails += postConnections;
}


let editedPostDetails = detectMatches(postDetails, searchArr, editedPostContent.relevance);

let relevanceArr = Object.keys(editedPostDetails.relevance).map((key) => {
    return {
        url: key,
        score: editedPostDetails.relevance[key]
    }
})

console.log(relevanceArr);

relevanceArr.sort((a, b) => b.score - a.score);


// TODO - Point category breadcrumb to filtered project page
// TODO - Tooltips reveal internal link article description

---

<BaseLayout pageTitle={frontmatter.title}>
    <main class="post">
        <SidePanel activeProject={activeProject} activePost={frontmatter.url}/>
        <article>
            <div class="breadcrumbs">
                {pagePath.map((step, index) => {
                    if (index == 0){
                        return ''
                    } else if (index == 1){
                        return <a href={`../../${step}`}>{toTitleCase(step)}</a><IconArrow />
                    } else if (index == 2){
                        return <a href={`../../${pagePath[1]}#${step}`}>{toTitleCase(step)}</a><IconArrow />
                    } else {
                        return <a href={step}>{frontmatter.title}</a>
                    }
                })}
            </div>
            <h1>{frontmatter.title}</h1>
            <img src="" />
            <section class="details" set:html={editedPostDetails.string}></section>
            <section class="content">
                <div set:html={editedPostContent.string}></div>
                <!-- <slot /> -->
            </section>
            <section class="related"></section>
        </article>
    </main>
</BaseLayout>
